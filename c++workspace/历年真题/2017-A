一、简答题：
1、常用有几种循环方法，他们各自有什么特点
答：常用三种循环方法，分别是 while,do...while,for.
    特点：
      while:其结构为while(条件){代码块}，即条件如果成立就执行代码快，每次都必须先判断条件，条件不符合，一次都不执行。
      do...while:结构为do{代码块}while(条件)，第一次执行时，先执行代码快，后判断条件，如果条件不符合，最少也能执行一次。
      for:结构为for(语句1;语句2;语句3){代码块},第一次先执行语句一，初始化控制变量，在执行语句二进行判断，然后执行代码块，
      在执行语句三，变化控制变量，在执行语句二进行判断，判断通过指向代码快，判断不通过跳出循环。
补充：
   1、用while和do……while时循环变量的初始化应在while和do……while的语句块执行之前完成，而for语句可以在语句1中实现循环变量的初始化。
   2、在使用这三个循环时，都可以用break语句跳出循环，用continue语句结束本次循环。
考题出处：第五章6节几种循环的比较   
2、当一个表达式同时包含整型，实型和字符型数据，其混合运算的规则是什么？
答：混合运算的规则：
      混合运算时，会自动进行变量转换，比如整型与实型运算时，会自动转化为double的类型进行计算，而字符串则会自动转化为ascii码来进行混合运算
正解：如果一个运算符的两侧的数据类型不同，则先自动进行类型转换，使二者具有同一类型，然后进行计算。其规律如下：
	(1):+,-,*,/运算的两个数中有一个数为float或double型，结果是double型，因为系统将所有的float型数据都先转换为double型，然后在进行计算
	(2):如果是int型与float或double型数据进行计算，型把int型和float型转化为double型，在进行计算，结果是double型
	(3):字符（char）型数据与整型数据进行计算，就是把字符的ascii代码与整型数据进行计算。可以直接与整型进行计算，
	    如果是与实型数据（double）进行运算，则先将字符型的ascii代码转化为double型，然后进行运算。
考题出处：第3章3.2.7.4不同类型数据间的混合运算。
总结：大致方向自己是有的，可能是缺少自信，没有将每一点都说到。分点分情况讨论。
二、程序阅读题
1、
#include<stdio.h>
void inv(int x[],int n){
  int t,i,j;
  for(i=0;i<n/2;i++){
    j=n-1-i;
    t=x[i];
    x[i]=x[j];
    x[j]=t;
  }
}
int main(){
  int i,a[5]={3,7,9,11,0};
  inv(a,5);
  for(i=0;i<5;i++){
    printf("%d ",a[i]);
  }
  printf("\n");
  return 0;
}
程序运行后输出的结果为：0,11,9,7,3
总结：此题是将一维数据里的元素，按逆序输出。inv()函数，中for循环i执行数组长度的一半次数，n-1-i与i正好以中间数对称，借助temp进行交换。
考题出处：第6章习题5
2、(错)
#include<stdio.h>
void main(){
  int a,b[10],c,i=0;
  printf("请输入一个整数：\n");
  scanf("%d",&a);
  while(a!=0){
    c=a%2;
    a=a/2;
    b[i]=c;
    i++;
  }
  for(;i>0;i--){
    printf("%d",b[i-1]);
  }
}
程序运行后，输入数字5，则输出的结果为：0,1  正确为： 1,0,1
注：最后输出时b[i-1],i++=3但是没有执行，所以最终i=3.及输出数据i的初始值为3
考点：while循环的使用，%:求余，/:整除的区别
题目出处：外围题。
3、（错）
#include<stdio.h>
void main(){
  int k=2,i=2,m;
  m=(k+=i*=k); 			//i=i*k 即i=4,k=k+i,k=6
  printf("%d,%d\n",m,i);
}
程序运行之后输出结果为：8,4 正确结果为6,4
考点：赋值表达式，先乘除后加减，同时也要注意。
题目出处：3.2.7.3算术表达式和运算符的优先级与结合性
4、
#include<stdio.h>
void main(){
  int a=15,b=21,m=0;
  switch(a%3){
  case 0:
    m++;
  case 1:
    m++;
    switch(b%2){
    default:
      m++;
    case 0:
      m++;
      break;
    }
  }
  printf("%d\n",m);
}
程序运行后输出的结果为：4
考点：switch……case结构 与break退出当前循环的使用，如果没有break语句，函数就会有上往下一直循序执行
题目出处：4.7 (p104)switch……case的8点说明。
5、（错）
#include<stdio.h>
void main(){
  int x=15;
  while(x>10 && x<50){
    x++;
    if(!(x%3)){
      x++;
      break;
    }
    else 
      continue;
  }
  printf("%d\n",x);
}
程序运行之后的结果为：18正确答案19
注意:不符合条件但还是对x++然后在break,所以尽管是18时不符合条件，但还是会+1.
三、根据流程图写程序
1、有一个mxn的矩阵，要求根据下面流程图写出程序来求出其中最大的那个元素的值，以及所在的行号个列号
#include<stdio.h>
void max_value(int a[m][n]){
  int max = a[0][0],i,j,row,column;
  for(i=0;i<m;i++){
    for(j=0;j<n;j++){
      if(a[i][j]>max){
        max=a[i][j];
        row=i;
        column=j;
      }
    }
  }
  printf("output:%d,%d and %d",max,row,column);
}
总结：我的思路是正确的，但应该写在main()函数中。
题目出处：第5章例5
四、程序填空
1、输入两个整数，求他们的最大公约数和最小公倍数
#include"stdio.h"
#include"conio.h"
void main(){
  int a,b,num1,num2,temp;
  printf("请输入两个整数：\n");
  scanf("%d,%d",&num1,&num2); 1
  if(num1<num2){//交换两个数，使最大数放在num1上
    temp=num1;
    num1=num2;
    num2=temp;
  }
  a=num1;b=num2;
  while(b!=0){ //利用辗除法，直到b=0为止
    temp=a%b;   2
    a=b;        3
    b=temp;     4
  }
  printf("最大公约数是：%d\n",a);
  printf("最小公倍数是:%d\n",num1*num2/a);
}
填空 1:scanf("%d,%d",&num1,&num2); 2:temp=a%b; 3:a=b; 4:b=temp;
考点：辗除法求最小公倍数与最大公约数。
      辗除法：设两个整数m、n，求m除以n的余数p,若p!=0,则将上次的除数做被除数，上次的余数做除数，继续求余数如此循环，直到p=0
题目出处：第7张习题1(16年最后一题)
2(错)、如果一个数恰好等于他所有因子之和，这个数就称为“完数”，例如：6=1+2+3，编写程序找出1000一内所有的完数。
#include<stdio.h>
int main(){
	int i,j,s;
	for(j=2;j<1000;j++){
		s=j;
		for(i=1;i<j;i++){
			if(j%i==0){
				s=s-i;
			}
		}
		if(s==0)
			printf("是完数：%d\n",i);
	}
	return 0;
}
填空 1:i=0;i<i;i++  2:s+=i != s*=i 3:continue 正解1:i=1;i<j;i++ 2:(j%i)==0 3:s=s-i
总结:空1循环j,空2判断j能不能被i整除 能整除就执行空3 s=s+i;
     空2i能被j整除=0，则说明i是j的约数，空3,s=s+i,因为因子相乘=因子之和此处s是用于计算因子之和。后面对s会进行判断
考题出处：第五章习题9
3.猴子吃桃的问题，猴子第一天摘下若干个桃子，当即吃了一半还不过瘾，有多吃了一个，
第二天早上又将剩下的桃子吃了一半，又多吃一个，以后每天早上都吃了前一天剩下的一半零一个，
到第10天早上在吃时，见只剩下一个桃子了，求第一天一共摘了多少
提示：采取逆向思维的方法，从后往前推断。
#include"stdio.h"
#include"conio.h"
void main(void){
  int day,x1,x2;
  day=9;
  x2=1;
  while(day>0){
    x1=2*x2+1;  1      //（第二天桃子数+1）*2 = 第一天桃子数
    x2=x1;      2      //第一天桃子数与第二天桃子数进行交换
    day--;      3      //控制循环的执行
  }
  printf("the total is %d\n",x1);
}
填空 （错）1:x1=(x2+1)*2  2:x2=x1  3:day--
总结：要将x1与x2进行交换，来转化第一天与第二天的桃子数，同时第二天的桃子数+1的2倍=第一天的桃子数
题目出处：第5章习题12
五、程序设计题
1、编写程序打印出100-999之间所有的‘水仙花数’，所谓“水仙花数”是指一个三位数，其各位数字的立方和等于该数本身，
例如：153是一个“水仙花数”，因为153=1的三次方+5的三次方+3的三次方。
#include<stdio.h>
#include<math.h>
int main(){
    /*
     * 一个三位数，这个数的每位数的立方，和=该位数
     * /:整除   %：取余
     */
    int n=100,i,j,k;
    for(;n<=1000;n++){
	i=n/100;		 //获取百位数字
(错)    j=n/10-i*10;		//获取十位数字
	k=n%10;			//获取各位数字
	if(n==i*i*i+j*j*j+k*k*k)//判断他们相等即为水仙花数
	    printf("%d\n",n);
    }
    return 0;
}
错误：获取十位数字出错，应该是要用十位数字减去百位数。
总结：关键是看清楚题目仔细考虑到每一个点，不能想当然。充分考虑清楚获取个十百每个位上的数字
题目出处：第五章习题8
2、设计一个程序，计算序列：2/1,3/2,5/3,8/5,13/8,21/13前20项之和。
#include<stdio.h>
int main(){
  //定义分子，分母，总和，i
  int a=2,b=1,i,t;
  float sum;
  for(i=0;i<20;i++){
    sum += a/b;
    t=a;
    a=a+b;
    b=t;
  }
  printf("前20项之和为：%.2f",sum);
  return 0;
}
总结：思路对，但问题出：换值有问题，任何换值都需要使用中间变量temp进行。
考题出处：第5章习题10
3（错）、编写程序，实现从键盘输入10个数，并用选择法从大到小排序。
简单选择排序的基本思想，第1趟在待排序记录r[1]-r[n]中选出最小的记录，将它与r[1]进行交换
第2趟，在待排序的r[2]-r[n]中选择最小的记录，将它与r[2]交换，以此类推，
第i趟在待排序记录r[i]-r[n]中选出最小的记录，与r[i]交换，使得有序数列不断增长直到全部排序完毕。
#include<stdio.h>
int main(){
  //定义变量
  int i a[10],min,temp;
  //用户输入数据
  for(i=0;i<10;i++){
    printf("please enter integer:\n");
    scanf("%d",&a[i]);
  }
  min =a[0];
  for(i=0;i<10;i++){
    if(a[i]>max){
      temp=max;
      max=a[i];
      a[i]=temp;
    }
  }
  //排序后输出
  for(i=0;i<10;i++){
    pritnf("%d",a[i]);
  }
  return 0;
}
正确：
#include<stdio.h>
int main(){
    /*
     * 假定一个小的数，然后与之比较，然后进行跟换下标
     */
    int a[10]={1,2,3,5,6,7,4,9,8,12};
    int min,mid;
    for(int i=0;i<10;i++){
	min = i;
	for(int j=i+1;j<10;j++){
	    if(a[min]>a[j]){		//自定义的a[min]与二轮循环的a[j]进行比较，如果大就交换下标
		min=j;			//先进行下标交换
		mid=a[i];		//再交换值
		a[i]=a[j];
		a[j]=mid;
	    }
	}
    }
    // 输出排序之后的结果
    for(int i=0;i<10;i++){
	printf(" %d",a[i]);
    }
    return 0;
}
总结：此题是要使用中间数，及下标，等来判断数组间元素值的大小，借助mid中间数来跟换下标，min也跟换下标，来实现。
题目出处：第6章习题2






















